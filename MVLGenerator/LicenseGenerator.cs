using System;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using static System.IO.Path;

namespace MVLGenerator;

[Generator]
public class LicenseGenerator : IIncrementalGenerator {
	public void Initialize(IncrementalGeneratorInitializationContext context) {
		var licenseFiles = context.AdditionalTextsProvider
			.Where(static file => GetFileName(file.Path)
				.StartsWith("LICENSE", StringComparison.OrdinalIgnoreCase));
		var compilationAndLicenses = context.CompilationProvider.Combine(licenseFiles.Collect());

		context.RegisterSourceOutput(compilationAndLicenses,
			static (spc, source) => {
				var entries = new StringBuilder();
				foreach (var licenseFile in source.Right) {
					var content = licenseFile.GetText(spc.CancellationToken)?.ToString();
					if (content == null) continue;

					var escapedValue = content.Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "");
					entries.AppendLine($$"""        ("{{GetFileName(GetDirectoryName(licenseFile.Path))}}", "{{escapedValue}}"),""");
				}

				spc.AddSource($"Info.License.g.cs",
					SourceText.From($$"""
									  // <auto-generated/>
									  using System.Collections.Generic;

									  public static partial class Info
									  {
									      public static IReadOnlyList<(string, string)> LICENSES { get; } = [
									  {{entries.ToString().TrimEnd(',', '\r', '\n')}}
									      ];
									  }
									  """,
						Encoding.UTF8));
			});
	}
}