using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

namespace MVLGenerator;

[Generator]
public class DictionaryGenerator : IIncrementalGenerator {
	public void Initialize(IncrementalGeneratorInitializationContext context) {
		var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
				"MVL.Utils.Attribute.JsonDictionaryAttribute",
				predicate: (node, _) => node is PropertyDeclarationSyntax,
				transform: GetTargetPropertySymbol)
			.Where(static m => m is not null);

		var valuesProvider = provider.Combine(context.AdditionalTextsProvider.Collect())
			.Combine(context.AnalyzerConfigOptionsProvider)
			.SelectMany<((PropertySymbolContext? Left, ImmutableArray<AdditionalText> Right) Left, AnalyzerConfigOptionsProvider
				Right), (string, string, string, string, string)>((tuple, _) => {
				var ((propertyContext, additionalTexts), options) = tuple;
				var (namespaceName, className, propertyName, jsonPath) = propertyContext!.Value;
				options.GlobalOptions.TryGetValue("build_property.projectdir", out var projectDir);
				var fullPath = Path.Combine(projectDir ?? "", jsonPath);
				foreach (var content in from text in additionalTexts
										where text.Path.Equals(fullPath, StringComparison.OrdinalIgnoreCase)
										select text.GetText()?.ToString()) {
					return [(namespaceName, className, propertyName, jsonPath, content!)];
				}

				return [(namespaceName, className, propertyName, jsonPath, "")];
			});
		context.RegisterSourceOutput(valuesProvider, GenerateSource);
	}

	static private PropertySymbolContext? GetTargetPropertySymbol(
		GeneratorAttributeSyntaxContext context,
		CancellationToken token) {
		var propertySymbol = (IPropertySymbol)context.TargetSymbol;
		var attribute = propertySymbol.GetAttributes()
			.FirstOrDefault(attr => attr.AttributeClass?.Name == "JsonDictionaryAttribute");

		if (attribute == null)
			return null;

		if (propertySymbol.Type.ToDisplayString() != "System.Collections.Generic.Dictionary<string, string>")
			return null;

		var jsonPath = attribute.ConstructorArguments[0].Value as string;
		if (string.IsNullOrEmpty(jsonPath))
			return null;

		return new PropertySymbolContext(
			propertySymbol.ContainingType.ContainingNamespace.ToDisplayString(),
			propertySymbol.ContainingType.Name,
			propertySymbol.Name,
			jsonPath!);
	}

	static private void GenerateSource(SourceProductionContext context, (string, string, string, string, string) valueTuple) {
		var (namespaceName, className, propertyName, jsonPath, jsonContent) = valueTuple;

		if (string.IsNullOrEmpty(jsonContent)) {
			return;
		}

		var entries = ParseJson(context, jsonContent);
		if (entries == null) {
			return;
		}

		var fieldName = "_" + char.ToLower(propertyName[0]) + propertyName.Substring(1);
		var source = GenerateClassSource(namespaceName, className, propertyName, fieldName, entries);
		context.AddSource($"{className}.{propertyName}.g.cs", SourceText.From(source, Encoding.UTF8));
	}

	static private Dictionary<string, string>? ParseJson(SourceProductionContext context, string jsonContent) {
		try {
			var options = new JsonSerializerOptions {
				AllowTrailingCommas = true,
				ReadCommentHandling = JsonCommentHandling.Skip
			};

			return JsonSerializer.Deserialize<Dictionary<string, string>>(jsonContent, options);
		} catch (JsonException ex) {
			context.ReportDiagnostic(Diagnostic.Create(
				new(
					"JD003",
					"JSON parse error",
					$"JSON parsing failed: {ex.Message}",
					"JsonDictionary",
					DiagnosticSeverity.Error,
					true),
				Location.None));
			return null;
		}
	}

	static private string GenerateClassSource(
		string namespaceName,
		string className,
		string propertyName,
		string fieldName,
		Dictionary<string, string> entries) {
		var entriesSource = string.Join(",\n\t\t", entries.Select(e => $"{{ \"{e.Key}\", \"{e.Value.Replace("\"", "\\\"")}\" }}"));
		return $$"""
				 // <auto-generated/>
				 using System.Collections.Generic;

				 namespace {{namespaceName}};
				 public partial class {{className}} {
				 	private static readonly Dictionary<string, string> {{fieldName}} = new() {
				 		{{entriesSource}}
				 	};

				 	static private partial Dictionary<string, string> {{propertyName}} { get => {{fieldName}}; }
				 }

				 """;
	}

	private readonly struct PropertySymbolContext(
		string namespaceName,
		string className,
		string propertyName,
		string jsonPath) {
		public readonly string NamespaceName = namespaceName;
		public readonly string ClassName = className;
		public readonly string PropertyName = propertyName;
		public readonly string JsonPath = jsonPath;

		public void Deconstruct(out string namespaceName, out string className, out string propertyName, out string jsonPath) {
			namespaceName = NamespaceName;
			className = ClassName;
			propertyName = PropertyName;
			jsonPath = JsonPath;
		}
	}
}